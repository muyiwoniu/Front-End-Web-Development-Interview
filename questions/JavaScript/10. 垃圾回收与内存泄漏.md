# 垃圾回收与内存泄漏



## 经典真题



- 请介绍一下 *JavaScript* 中的垃圾回收站机制



## 什么是内存泄露



程序的运行需要内存。只要程序提出要求，操作系统或者运行时（*runtime*）就必须供给内存。

对于持续运行的服务进程（*daemon*），必须及时释放不再用到的内存。否则，内存占用越来越高，轻则影响系统性能，重则导致进程崩溃。

也就是说，不再用到的内存，如果没有及时释放，就叫做内存泄漏（*memory leak*）。



## *JavaScript* 中的垃圾回收



浏览器的 *Javascript* 具有自动垃圾回收机制（*GC*：*Garbage Collecation*），也就是说，执行环境会负责管理代码执行过程中使用的内存。其原理是：**垃圾收集器会定期（周期性）找出那些不在继续使用的变量，然后释放其内存**。

但是这个过程不是实时的，因为其开销比较大并且 *GC* 时停止响应其他操作，所以垃圾回收器会按照固定的时间间隔周期性的执行。

不再使用的变量也就是生命周期结束的变量，当然只可能是局部变量，全局变量的生命周期直至浏览器卸载页面才会结束。局部变量只在函数的执行过程中存在，而在这个过程中会为局部变量在栈或堆上分配相应的空间，以存储它们的值，然后在函数中使用这些变量，直至函数结束，而闭包中由于内部函数的原因，外部函数并不能算是结束。



下面是一段示例代码：

```js
function fn1() {
    var obj = {name: 'zhangsan', age: 10};
}
function fn2() {
    var obj = {name:'zhangsan', age: 10};
    return obj;
}

var a = fn1();
var b = fn2();
```

在上面的代码中，我们首先声明了两个函数，分别叫做 *fn1* 和 *fn2*。

当 *fn1* 被调用时，进入 *fn1* 的环境，会开辟一块内存存放对象 *{name: 'zhangsan', age: 10}*。而当调用结束后，出了 *fn1* 的环境，那么该块内存会被  *JavaScript* 引擎中的垃圾回收器自动释放；

在 *fn2* 被调用的过程中，返回的对象被全局变量 *b* 所指向，所以该块内存并不会被释放。

这里问题就出现了：到底哪个变量是没有用的？

所以垃圾收集器必须跟踪到底哪个变量没用，对于不再有用的变量打上标记，以备将来收回其内存。

用于标记的无用变量的策略可能因实现而有所区别，通常情况下有两种实现方式：**标记清除**和**引用计数**。

引用计数不太常用，标记清除较为常用。



## 标记清除



*JavaScript* 中最常用的垃圾回收方式就是标记清除。

当变量进入环境时，例如，在函数中声明一个变量，就将这个变量标记为“进入环境”。

从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到它们。

而当变量离开环境时，则将其标记为“离开环境”。

```js
function test(){
  var a = 10 ; // 被标记 ，进入环境 
  var b = 20 ; // 被标记 ，进入环境
}
test(); // 执行完毕 之后 a、b 又被标离开环境，被回收。
```

垃圾回收器在运行的时候会给存储在内存中的所有变量都加上标记（当然，可以使用任何标记方式）。

然后，它会去掉环境中的变量以及被环境中的变量引用的变量的标记（闭包）。而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。

最后，垃圾回收器完成内存清除工作，销毁那些带标记的值并回收它们所占用的内存空间。

到目前为止，*IE9+、Firefox、Opera、Chrome、Safari* 的 *JS* 实现使用的都是标记清除的垃圾回收策略或类似的策略，只不过垃圾收集的时间间隔互不相同。



## 引用计数



引用计数的含义是跟踪记录每个值被引用的次数。

当声明了一个变量并将一个引用类型值赋给该变量时，则这个值的引用次数就是 *1*。如果同一个值又被赋给另一个变量，则该值的引用次数加 *1*。

相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数减 *1*。当这个值的引用次数变成 *0* 时，则说明没有办法再访问这个值了，因而就可以将其占用的内存空间回收回来。

这样，当垃圾回收器下次再运行时，它就会释放那些引用次数为 *0* 的值所占用的内存。

```js
function test() {
    var a = {};	// a 指向对象的引用次数为 1
    var b = a;	// a 指向对象的引用次数加 1，为 2
    var c = a;	// a 指向对象的引用次数再加 1，为 3
    var b = {};	// a 指向对象的引用次数减 1，为 2
}
```

*Netscape Navigator3* 是最早使用引用计数策略的浏览器，但很快它就遇到一个严重的问题：**循环引用**。

循环引用指的是对象 *A* 中包含一个指向对象B的指针，而对象 *B* 中也包含一个指向对象 *A* 的引用。

```js
function fn() {
    var a = {};
    var b = {};
    a.pro = b;
    b.pro = a;
}
fn();
```

以上代码 *a* 和 *b* 的引用次数都是 *2*，*fn* 执行完毕后，两个对象都已经离开环境，在标记清除方式下是没有问题的，但是在引用计数策略下，因为 *a* 和 *b* 的引用次数不为 *0*，所以不会被垃圾回收器回收内存，如果 *fn* 函数被大量调用，就会造成内存泄露。在 *IE7* 与 *IE8* 上，内存直线上升。



## *IE* 中的内存泄露问题



在 *IE* 中，有一部分对象并不是原生 *JS* 对象。

例如，其内存泄露 *DOM* 和 *BOM* 中的对象就是使用 *C++* 以 *COM* 对象的形式实现的，而 *COM* 对象的垃圾回收机制采用的就是引用计数策略。

因此，即使 *IE* 的 *JS* 引擎采用标记清除策略来实现，但 *JS* 访问的 **COM 对象依然是基于引用计数策略**的。换句话说，只要在 *IE* 中涉及 *COM* 对象，就会存在循环引用的问题。

```js
var element = document.getElementById("some_element");
var myObject = new Object();
myObject.e = element;
element.o = myObject;
```

这个例子在一个 *DOM* 元素 *element* 与一个原生 *JS* 对象 *myObject* 之间创建了循环引用。

其中，变量 *myObject* 有一个属性 *e* 指向 *element* 对象；而变量 *element* 也有一个属性 *o* 回指 *myObject*。

由于存在这个循环引用，即使例子中的 *DOM* 从页面中移除，它也永远不会被回收。

举个例子：

![3858568291-5d764e9c8fc3a](https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-09-30-131253.gif)

- 黄色是指直接被 *JS* 变量所引用，在内存里
- 红色是指间接被 *JS* 变量所引用，如上图，*refB* 被 *refA* 间接引用，导致即使 *refB* 变量被清空，也是不会被回收的
- 子元素 *refB* 由于 *parentNode* 的间接引用，只要它不被删除，它所有的父元素（图中红色部分）都不会被删除



另一个例子：

```js
window.onload=function outerFunction(){
    var obj = document.getElementById("element");
    obj.onclick=function innerFunction(){};
};
```

这段代码看起来没什么问题。

但是 *obj* 引用了 *document.getElementById('element')*，而 *document.getElementById('element')* 的 *onclick* 方法会引用外部环境中的变量，自然也包括 *obj*，是不是很隐蔽啊。（在比较新的浏览器中在移除 *Node* 的时候已经会移除其上的 *event* 了，但是在老的浏览器，特别是 *IE* 上会有这个 *bug*）



**解决方法**



最简单的方式就是自己手工解除循环引用，比如刚才的函数可以这样：

```js
myObject.element = null;
element.o = null;

window.onload=function outerFunction(){
    var obj = document.getElementById("element");
    obj.onclick = function innerFunction(){};
    obj = null;
};
```

将变量设置为 *null* 意味着切断变量与它此前引用的值之间的连接。当垃圾回收器下次运行时，就会删除这些值并回收它们占用的内存。

要注意的是，*IE9+* 并不存在循环引用导致 *DOM* 内存泄露问题，可能是微软做了优化，或者 *DOM* 的回收方式已经改变。



## 内存管理



### 什么时候触发垃圾回收？



垃圾回收器周期性运行，如果分配的内存非常多，那么回收工作也会很艰巨，确定垃圾回收时间间隔就变成了一个值得思考的问题。

*IE6* 的垃圾回收是根据内存分配量运行的，当环境中存在 *256* 个变量、*4096* 个对象、*64k* 的字符串任意一种情况的时候就会触发垃圾回收器工作，看起来很科学，不用按一段时间就调用一次，有时候会没必要，这样按需调用不是很好吗？

但是如果环境中就是有这么多变量等一直存在，现在脚本如此复杂，很正常，那么结果就是垃圾回收器一直在工作，这样浏览器就没法儿玩儿了。

微软在 *IE7* 中做了调整，触发条件不再是固定的，而是动态修改的，初始值和 *IE6* 相同，如果垃圾回收器回收的内存分配量低于程序占用内存的 *15%*，说明大部分内存不可被回收，设的垃圾回收触发条件过于敏感，这时候把临街条件翻倍，如果回收的内存高于 *85%*，说明大部分内存早就该清理了，这时候把触发条件置回。这样就使垃圾回收工作职能了很多。



### 合理的 *GC* 方案



**基础方案**

*Javascript* 引擎基础 *GC* 方案是（*simple GC*）：*mark and sweep*（标记清除），即：

1. 遍历所有可访问的对象。
2. 回收已不可访问的对象。



***GC* 的缺陷**

和其他语言一样，*JS* 的 *GC* 策略也无法避免一个问题：*GC* 时，停止响应其他操作，这是为了安全考虑。

而 *Javascript* 的 *GC* 在 *100ms* 甚至以上，对一般的应用还好，但对于 *JS* 游戏，动画对连贯性要求比较高的应用，就麻烦了。这就是新引擎需要优化的点：避免 *GC* 造成的长时间停止响应。



***GC* 优化策略**

这里主要介绍 *2* 个优化策略：



（1）**分代回收**（*Generation GC*）

这个和 *Java* 回收策略思想是一致的，也是 *V8* 所主要采用的。

目的是通过区分“临时”与“持久”对象；多回收“临时对象”区（*young generation*），少回收“持久对象”区（*tenured generation*），减少每次需遍历的对象，从而减少每次 *GC* 的耗时。如图：

![preview](https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-09-30-132831.png)

这里需要补充的是：对于 *tenured generation* 对象，有额外的开销：把它从 *young generation* 迁移到 *tenured generation*，另外，如果被引用了，那引用的指向也需要修改。

（2）**增量 *GC***

这个方案的思想很简单，就是“每次处理一点，下次再处理一点，如此类推”。如图：

![preview](https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-09-30-132934.png)

这种方案，虽然耗时短，但中断较多，带来了上下文切换频繁的问题。

因为每种方案都其适用场景和缺点，因此在实际应用中，会根据实际情况选择方案。比如：低 (对象/s) 比率时，中断执行 *GC* 的频率，*simple GC* 更低些；如果大量对象都是长期“存活”，则分代处理优势也不大。



## 真题解答



- 请介绍一下 *JavaScript* 中的垃圾回收站机制

> 参考答案：
>
> *JavaScript* 具有自动垃圾回收机制。垃圾收集器会按照固定的时间间隔周期性的执行。
>
> *JavaScript* 常见的垃圾回收方式：**标记清除**、**引用计数**方式。
>
> 1、标记清除方式：
>
> - 工作原理：当变量进入环境时，将这个变量标记为“进入环境”。当变量离开环境时，则将其标记为“离开环境”。标记“离开环境”的就回收内存。
>
> - 工作流程：
>
>  - 垃圾回收器，在运行的时候会给存储在内存中的所有变量都加上标记；
>
>  - 去掉环境中的变量以及被环境中的变量引用的变量的标记；
>
>  - 被加上标记的会被视为准备删除的变量；
>
>  - 垃圾回收器完成内存清理工作，销毁那些带标记的值并回收他们所占用的内存空间。
>
> 2、引用计数方式：
>
> - 工作原理：跟踪记录每个值被引用的次数。
>
> - 工作流程：
>
>  - 声明了一个变量并将一个引用类型的值赋值给这个变量，这个引用类型值的引用次数就是 *1*；
>
>  - 同一个值又被赋值给另一个变量，这个引用类型值的引用次数加 *1*；
>
>  - 当包含这个引用类型值的变量又被赋值成另一个值了，那么这个引用类型值的引用次数减 *1*；
>
>  - 当引用次数变成 *0* 时，说明没办法访问这个值了；
>
>  - 当垃圾收集器下一次运行时，它就会释放引用次数是 *0* 的值所占的内存。



-*EOF*-

