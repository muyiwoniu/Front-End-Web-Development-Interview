## *Vue* 面试题相关

### 1. **谈一谈对 *MVVM* 的理解？**

> 参考答案：
>
> -  *MVVM* 是 *Model-View-ViewModel* 的缩写。*MVVM* 是一种设计思想。
>   - *Model* 层代表数据模型，也可以在 *Model* 中定义数据修改和操作的业务逻辑; 
>   - *View* 代表 *UI* 组件，它负责将数据模型转化成 *UI* 展现出来，*View* 是一个同步 *View* 和 *Model* 的对象
> - 在 *MVVM* 架构下，*View* 和 *Model* 之间并没有直接的联系，而是通过 *ViewModel* 进行交互， *Model* 和 *ViewModel* 之间的交互是双向的， 因此 *View* 数据的变化会同步到 *Model* 中，而 *Model* 数据的变化也会立即反应到 *View* 上。
> - 对 *ViewModel* 通过双向数据绑定把 *View* 层和 *Model* 层连接了起来，而 *View* 和 *Model* 之间的 同步工作完全是自动的，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作 *DOM*，不需要关注数据状态的同步问题，复杂的数据状态维护完全由 *MVVM* 来统一管理。



### 2. **说一下 *Vue* 的优点**

> 参考答案：
>
> *Vue* 是一个构建数据驱动的 *Web* 界面的渐进式框架。
>
> *Vue* 的目标是通过尽可能简单的 *API* 实现响应的数据绑定和组合的视图组件。核心是一个响应的数据绑定系统。
>
> 关于 *Vue* 的优点，主要有**响应式编程、组件化开发、虚拟 *DOM***
>
> **响应式编程**
>
> 这里的响应式不是 *@media* 媒体查询中的响应式布局，而是指 *Vue* 会自动对页面中某些数据的变化做出响应。这也就是 *Vue* 最大的优点，通过 *MVVM* 思想实现数据的双向绑定，让开发者不用再操作 *DOM* 对象，有更多的时间去思考业务逻辑。
>
> **组件化开发**
>
> *Vue* 通过组件，把一个单页应用中的各种模块拆分到一个一个单独的组件（*component*）中，我们只要先在父级应用中写好各种组件标签（占坑），并且在组件标签中写好要传入组件的参数（就像给函数传入参数一样，这个参数叫做组件的属性），然后再分别写好各种组件的实现（填坑），然后整个应用就算做完了。
>
> 组件化开发的优点：提高开发效率、方便重复使用、简化调试步骤、提升整个项目的可维护性、便于协同开发。
>
> **虚拟 *DOM***
>
> 在传统开发中，用 *JQuery* 或者原生的 *JavaScript DOM* 操作函数对 *DOM* 进行频繁操作的时候，浏览器要不停的渲染新的 *DOM* 树，导致在性能上面的开销特别的高。
>
> 而 *Virtual DOM* 则是虚拟 *DOM* 的英文，简单来说，它就是一种可以预先通过 *JavaScript* 进行各种计算，把最终的 *DOM* 操作计算出来并优化，由于这个 *DOM* 操作属于预处理操作，并没有真实的操作 *DOM*，所以叫做虚拟 *DOM*。最后在计算完毕才真正将 *DOM* 操作提交，将 *DOM* 操作变化反映到 *DOM* 树上。


### 3. **解释一下对 *Vue* 生命周期的理解**

- 什么是 *vue* 生命周期
- *vue* 生命周期的作用是什么
- *vue* 生命周期有几个阶段
- 第一次页面加载会触发哪几个钩子
- *DOM* 渲染在哪个周期就已经完成
- 多组件（父子组件）中生命周期的调用顺序说一下

> 参考答案：
>
> **什么是 *vue* 生命周期**
>
> 对于 *vue* 来讲，生命周期就是一个 *vue* 实例从创建到销毁的过程。
>
> 
>
> ***vue* 生命周期的作用是什么**
>
> 在生命周期的过程中会运行着一些叫做生命周期的函数，给予了开发者在不同的生命周期阶段添加业务代码的能力。
>
> 其实和回调是一个概念，当系统执行到某处时，检查是否有 *hook*(钩子)，有的话就会执行回调。
>
> 通俗的说，*hook* 就是在程序运行中，在某个特定的位置，框架的开发者设计好了一个钩子来告诉我们当前程序已经运行到特定的位置了，会触发一个回调函数，并提供给我们，让我们可以在生命周期的特定阶段进行相关业务代码的编写。
>
> 
>
> ***vue* 生命周期有几个阶段**
>
> 它可以总共分为 *8* 个阶段：创建前/后, 载入前/后,更新前/后,销毁前/销毁后。
>
> - *beforeCreate*：是 *new Vue( )* 之后触发的第一个钩子，在当前阶段 *data、methods、computed* 以及 *watch* 上的数据和方法都不能被访问。
>
> - *created*：在实例创建完成后发生，当前阶段已经完成了数据观测，也就是可以使用数据，更改数据，在这里更改数据不会触发 *updated* 函数。可以做一些初始数据的获取，在当前阶段无法与 *DOM* 进行交互，如果非要想，可以通过 *vm.$nextTick* 来访问 *DOM* 。
>
> - *beforeMount*：发生在挂载之前，在这之前 *template* 模板已导入渲染函数编译。而当前阶段虚拟 *DOM* 已经创建完成，即将开始渲染。在此时也可以对数据进行更改，不会触发 *updated*。
>
> - *mounted*：在挂载完成后发生，在当前阶段，真实的 *DOM* 挂载完毕，数据完成双向绑定，可以访问到 *DOM* 节点，使用 *$refs* 属性对 *DOM* 进行操作。
>
> - *beforeUpdate*：发生在更新之前，也就是响应式数据发生更新，虚拟 *DOM* 重新渲染之前被触发，你可以在当前阶段进行更改数据，不会造成重渲染。
>
> - *updated*：发生在更新完成之后，当前阶段组件 *DOM* 已完成更新。要注意的是避免在此期间更改数据，因为这可能会导致无限循环的更新。
>
> - *beforeDestroy*：发生在实例销毁之前，在当前阶段实例完全可以被使用，我们可以在这时进行善后收尾工作，比如清除计时器。
>
> - *destroyed*：发生在实例销毁之后，这个时候只剩下了 *DOM* 空壳。组件已被拆解，数据绑定被卸除，监听被移出，子实例也统统被销毁。
>
> 
>
> **第一次页面加载会触发哪几个钩子**
>
> 会触发 *4* 个钩子，分别是：*beforeCreate、created、beforeMount、mounted*
>
> 
>
> ***DOM* 渲染在哪个周期就已经完成**
>
> *DOM* 渲染是在 *mounted* 阶段完成，此阶段真实的 *DOM* 挂载完毕，数据完成双向绑定，可以访问到 *DOM* 节点。
>
> 
>
> **多组件（父子组件）中生命周期的调用顺序说一下**
>
> 组件的调用顺序都是先父后子，渲染完成的顺序是先子后父。组件的销毁操作是先父后子，销毁完成的顺序是先子后父。
>
> - 加载渲染过程：父*beforeCreate*->父*created*->父*beforeMount*->子*beforeCreate*->子*created*->子*beforeMount*- >子*mounted*->父*mounted*
>
> - 子组件更新过程：父*beforeUpdate*->子*beforeUpdate*->子*updated*->父*updated*
>
> - 父组件更新过程：父 *beforeUpdate* -> 父 *updated*
>
> - 销毁过程：父*beforeDestroy*->子*beforeDestroy*->子*destroyed*->父*destroyed*



### 4. ***Vue* 实现双向数据绑定原理是什么？**

> 参考答案：
>
> *Vue2.x* 采用数据劫持结合发布订阅模式（*PubSub* 模式）的方式，通过 *Object.defineProperty* 来劫持各个属性的 *setter、getter*，在数据变动时发布消息给订阅者，触发相应的监听回调。
>
> 当把一个普通 *Javascript* 对象传给 *Vue* 实例来作为它的 *data* 选项时，*Vue* 将遍历它的属性，用 *Object.defineProperty* 将它们转为 *getter/setter*。用户看不到 *getter/setter*，但是在内部它们让 *Vue* 追踪依赖，在属性被访问和修改时通知变化。
>
> *Vue* 的数据双向绑定整合了 *Observer*，*Compile* 和 *Watcher* 三者，通过 *Observer* 来监听自己的 *model* 的数据变化，通过 *Compile* 来解析编译模板指令，最终利用 *Watcher* 搭起 *Observer* 和 *Compile* 之间的通信桥梁，达到数据变化->视图更新，视图交互变化（例如 input 操作）->数据 *model* 变更的双向绑定效果。
>
> *Vue3.x* 放弃了 *Object.defineProperty* ，使用 *ES6* 原生的 *Proxy*，来解决以前使用  *Object.defineProperty* 所存在的一些问题。



### 5. **说一下对 *Vue2.x* 响应式原理的理解**

> 参考答案：
>
> *Vue* 在初始化数据时，会使用 *Object.defineProperty* 重新定义 *data* 中的所有属性，当页面使用对应属性时，首先会进行依赖收集(收集当前组件的 *watcher*)，如果属性发生变化会通知相关依赖进行更新操作(发布订阅)。
>
> （可以参阅前面第 *4* 题答案）


