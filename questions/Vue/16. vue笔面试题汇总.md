## *Vue* 面试题相关

### 1. **谈一谈对 *MVVM* 的理解？**

> 参考答案：
>
> -  *MVVM* 是 *Model-View-ViewModel* 的缩写。*MVVM* 是一种设计思想。
>   - *Model* 层代表数据模型，也可以在 *Model* 中定义数据修改和操作的业务逻辑; 
>   - *View* 代表 *UI* 组件，它负责将数据模型转化成 *UI* 展现出来，*View* 是一个同步 *View* 和 *Model* 的对象
> - 在 *MVVM* 架构下，*View* 和 *Model* 之间并没有直接的联系，而是通过 *ViewModel* 进行交互， *Model* 和 *ViewModel* 之间的交互是双向的， 因此 *View* 数据的变化会同步到 *Model* 中，而 *Model* 数据的变化也会立即反应到 *View* 上。
> - 对 *ViewModel* 通过双向数据绑定把 *View* 层和 *Model* 层连接了起来，而 *View* 和 *Model* 之间的 同步工作完全是自动的，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作 *DOM*，不需要关注数据状态的同步问题，复杂的数据状态维护完全由 *MVVM* 来统一管理。



### 2. **说一下 *Vue* 的优点**

> 参考答案：
>
> *Vue* 是一个构建数据驱动的 *Web* 界面的渐进式框架。
>
> *Vue* 的目标是通过尽可能简单的 *API* 实现响应的数据绑定和组合的视图组件。核心是一个响应的数据绑定系统。
>
> 关于 *Vue* 的优点，主要有**响应式编程、组件化开发、虚拟 *DOM***
>
> **响应式编程**
>
> 这里的响应式不是 *@media* 媒体查询中的响应式布局，而是指 *Vue* 会自动对页面中某些数据的变化做出响应。这也就是 *Vue* 最大的优点，通过 *MVVM* 思想实现数据的双向绑定，让开发者不用再操作 *DOM* 对象，有更多的时间去思考业务逻辑。
>
> **组件化开发**
>
> *Vue* 通过组件，把一个单页应用中的各种模块拆分到一个一个单独的组件（*component*）中，我们只要先在父级应用中写好各种组件标签（占坑），并且在组件标签中写好要传入组件的参数（就像给函数传入参数一样，这个参数叫做组件的属性），然后再分别写好各种组件的实现（填坑），然后整个应用就算做完了。
>
> 组件化开发的优点：提高开发效率、方便重复使用、简化调试步骤、提升整个项目的可维护性、便于协同开发。
>
> **虚拟 *DOM***
>
> 在传统开发中，用 *JQuery* 或者原生的 *JavaScript DOM* 操作函数对 *DOM* 进行频繁操作的时候，浏览器要不停的渲染新的 *DOM* 树，导致在性能上面的开销特别的高。
>
> 而 *Virtual DOM* 则是虚拟 *DOM* 的英文，简单来说，它就是一种可以预先通过 *JavaScript* 进行各种计算，把最终的 *DOM* 操作计算出来并优化，由于这个 *DOM* 操作属于预处理操作，并没有真实的操作 *DOM*，所以叫做虚拟 *DOM*。最后在计算完毕才真正将 *DOM* 操作提交，将 *DOM* 操作变化反映到 *DOM* 树上。


### 3. **解释一下对 *Vue* 生命周期的理解**

- 什么是 *vue* 生命周期
- *vue* 生命周期的作用是什么
- *vue* 生命周期有几个阶段
- 第一次页面加载会触发哪几个钩子
- *DOM* 渲染在哪个周期就已经完成
- 多组件（父子组件）中生命周期的调用顺序说一下

> 参考答案：
>
> **什么是 *vue* 生命周期**
>
> 对于 *vue* 来讲，生命周期就是一个 *vue* 实例从创建到销毁的过程。
>
> 
>
> ***vue* 生命周期的作用是什么**
>
> 在生命周期的过程中会运行着一些叫做生命周期的函数，给予了开发者在不同的生命周期阶段添加业务代码的能力。
>
> 其实和回调是一个概念，当系统执行到某处时，检查是否有 *hook*(钩子)，有的话就会执行回调。
>
> 通俗的说，*hook* 就是在程序运行中，在某个特定的位置，框架的开发者设计好了一个钩子来告诉我们当前程序已经运行到特定的位置了，会触发一个回调函数，并提供给我们，让我们可以在生命周期的特定阶段进行相关业务代码的编写。
>
> 
>
> ***vue* 生命周期有几个阶段**
>
> 它可以总共分为 *8* 个阶段：创建前/后, 载入前/后,更新前/后,销毁前/销毁后。
>
> - *beforeCreate*：是 *new Vue( )* 之后触发的第一个钩子，在当前阶段 *data、methods、computed* 以及 *watch* 上的数据和方法都不能被访问。
>
> - *created*：在实例创建完成后发生，当前阶段已经完成了数据观测，也就是可以使用数据，更改数据，在这里更改数据不会触发 *updated* 函数。可以做一些初始数据的获取，在当前阶段无法与 *DOM* 进行交互，如果非要想，可以通过 *vm.$nextTick* 来访问 *DOM* 。
>
> - *beforeMount*：发生在挂载之前，在这之前 *template* 模板已导入渲染函数编译。而当前阶段虚拟 *DOM* 已经创建完成，即将开始渲染。在此时也可以对数据进行更改，不会触发 *updated*。
>
> - *mounted*：在挂载完成后发生，在当前阶段，真实的 *DOM* 挂载完毕，数据完成双向绑定，可以访问到 *DOM* 节点，使用 *$refs* 属性对 *DOM* 进行操作。
>
> - *beforeUpdate*：发生在更新之前，也就是响应式数据发生更新，虚拟 *DOM* 重新渲染之前被触发，你可以在当前阶段进行更改数据，不会造成重渲染。
>
> - *updated*：发生在更新完成之后，当前阶段组件 *DOM* 已完成更新。要注意的是避免在此期间更改数据，因为这可能会导致无限循环的更新。
>
> - *beforeDestroy*：发生在实例销毁之前，在当前阶段实例完全可以被使用，我们可以在这时进行善后收尾工作，比如清除计时器。
>
> - *destroyed*：发生在实例销毁之后，这个时候只剩下了 *DOM* 空壳。组件已被拆解，数据绑定被卸除，监听被移出，子实例也统统被销毁。
>
> 
>
> **第一次页面加载会触发哪几个钩子**
>
> 会触发 *4* 个钩子，分别是：*beforeCreate、created、beforeMount、mounted*
>
> 
>
> ***DOM* 渲染在哪个周期就已经完成**
>
> *DOM* 渲染是在 *mounted* 阶段完成，此阶段真实的 *DOM* 挂载完毕，数据完成双向绑定，可以访问到 *DOM* 节点。
>
> 
>
> **多组件（父子组件）中生命周期的调用顺序说一下**
>
> 组件的调用顺序都是先父后子，渲染完成的顺序是先子后父。组件的销毁操作是先父后子，销毁完成的顺序是先子后父。
>
> - 加载渲染过程：父*beforeCreate*->父*created*->父*beforeMount*->子*beforeCreate*->子*created*->子*beforeMount*- >子*mounted*->父*mounted*
>
> - 子组件更新过程：父*beforeUpdate*->子*beforeUpdate*->子*updated*->父*updated*
>
> - 父组件更新过程：父 *beforeUpdate* -> 父 *updated*
>
> - 销毁过程：父*beforeDestroy*->子*beforeDestroy*->子*destroyed*->父*destroyed*



### 4. ***Vue* 实现双向数据绑定原理是什么？**

> 参考答案：
>
> *Vue2.x* 采用数据劫持结合发布订阅模式（*PubSub* 模式）的方式，通过 *Object.defineProperty* 来劫持各个属性的 *setter、getter*，在数据变动时发布消息给订阅者，触发相应的监听回调。
>
> 当把一个普通 *Javascript* 对象传给 *Vue* 实例来作为它的 *data* 选项时，*Vue* 将遍历它的属性，用 *Object.defineProperty* 将它们转为 *getter/setter*。用户看不到 *getter/setter*，但是在内部它们让 *Vue* 追踪依赖，在属性被访问和修改时通知变化。
>
> *Vue* 的数据双向绑定整合了 *Observer*，*Compile* 和 *Watcher* 三者，通过 *Observer* 来监听自己的 *model* 的数据变化，通过 *Compile* 来解析编译模板指令，最终利用 *Watcher* 搭起 *Observer* 和 *Compile* 之间的通信桥梁，达到数据变化->视图更新，视图交互变化（例如 input 操作）->数据 *model* 变更的双向绑定效果。
>
> *Vue3.x* 放弃了 *Object.defineProperty* ，使用 *ES6* 原生的 *Proxy*，来解决以前使用  *Object.defineProperty* 所存在的一些问题。



### 5. **说一下对 *Vue2.x* 响应式原理的理解**

> 参考答案：
>
> *Vue* 在初始化数据时，会使用 *Object.defineProperty* 重新定义 *data* 中的所有属性，当页面使用对应属性时，首先会进行依赖收集(收集当前组件的 *watcher*)，如果属性发生变化会通知相关依赖进行更新操作(发布订阅)。
>
> （可以参阅前面第 *4* 题答案）



### 6. **说一下在 *Vue2.x* 中如何检测数组的变化？**

> 参考答案：
>
> *Vue2.x* 中实现检测数组变化的方法，是**将数组的常用方法进行了重写**。*Vue* 将 *data* 中的数组进行了原型链重写，指向了自己定义的数组原型方法。这样当调用数组 *api* 时，可以通知依赖更新。如果数组中包含着引用类型，会对数组中的引用类型再次递归遍历进行监控。这样就实现了监测数组变化。
>
> 流程:
>
> 1. 初始化传入 data 数据执行 initData
> 2. 将数据进行观测 new Observer
> 3. 将数组原型方法指向重写的原型
> 4. 深度观察数组中的引用类型
>
> 有两种情况无法检测到数组的变化。
>
> - 当利用索引直接设置一个数组项时，例如 *vm.items[indexOfItem] = newValue*
> - 当修改数组的长度时，例如 *vm.items.length = newLength*
>
> 不过这两种场景都有对应的解决方案。
>
> **利用索引设置数组项的替代方案**
>
> ```js
> //使用该方法进行更新视图
> // vm.$set，Vue.set的一个别名
> vm.$set(vm.items, indexOfItem, newValue)
> ```
>
> **修改数组的长度的替代方案**
>
> ```js
> //使用该方法进行更新视图
> // Array.prototype.splice
> vm.items.splice(indexOfItem, 1, newValue)
> ```



### 6. **说一下在 *Vue2.x* 中如何检测数组的变化？**

> 参考答案：
>
> *Vue2.x* 中实现检测数组变化的方法，是**将数组的常用方法进行了重写**。*Vue* 将 *data* 中的数组进行了原型链重写，指向了自己定义的数组原型方法。这样当调用数组 *api* 时，可以通知依赖更新。如果数组中包含着引用类型，会对数组中的引用类型再次递归遍历进行监控。这样就实现了监测数组变化。
>
> 流程:
>
> 1. 初始化传入 data 数据执行 initData
> 2. 将数据进行观测 new Observer
> 3. 将数组原型方法指向重写的原型
> 4. 深度观察数组中的引用类型
>
> 有两种情况无法检测到数组的变化。
>
> - 当利用索引直接设置一个数组项时，例如 *vm.items[indexOfItem] = newValue*
> - 当修改数组的长度时，例如 *vm.items.length = newLength*
>
> 不过这两种场景都有对应的解决方案。
>
> **利用索引设置数组项的替代方案**
>
> ```js
> //使用该方法进行更新视图
> // vm.$set，Vue.set的一个别名
> vm.$set(vm.items, indexOfItem, newValue)
> ```
>
> **修改数组的长度的替代方案**
>
> ```js
> //使用该方法进行更新视图
> // Array.prototype.splice
> vm.items.splice(indexOfItem, 1, newValue)
> ```



### 7. ***Vue3.x* 响应式数据**

- *Vue3.x* 响应式数据原理是什么？
- *Proxy* 只会代理对象的第一层，那么 *Vue3* 又是怎样处理这个问题的呢？
- 监测数组的时候可能触发多次 *get/set*，那么如何防止触发多次呢？

> 参考答案：
>
> ***Vue3.x* 响应式数据原理是什么？**
>
> 在 *Vue 2* 中，响应式原理就是使用的 *Object.defineProperty* 来实现的。但是在 *Vue 3.0* 中采用了 *Proxy*，抛弃了 *Object.defineProperty* 方法。
>
> 究其原因，主要是以下几点：
>
> - *Object.defineProperty* 无法监控到数组下标的变化，导致通过数组下标添加元素，不能实时响应
> - *Object.defineProperty* 只能劫持对象的属性，从而需要对每个对象，每个属性进行遍历，如果，属性值是对象，还需要深度遍历。*Proxy* 可以劫持整个对象，并返回一个新的对象。
> - *Proxy* 不仅可以代理对象，还可以代理数组。还可以代理动态增加的属性。
> - *Proxy* 有多达 *13* 种拦截方法
> - *Proxy*作为新标准将受到浏览器厂商重点持续的性能优化
>
> 
>
> ***Proxy* 只会代理对象的第一层，那么 *Vue3* 又是怎样处理这个问题的呢？**
>
> 判断当前 *Reflect.get* 的返回值是否为 *Object*，如果是则再通过 *reactive* 方法做代理， 这样就实现了深度观测。
>
> 
>
> **监测数组的时候可能触发多次 *get/set*，那么如何防止触发多次呢？**
>
> 我们可以判断 *key* 是否为当前被代理对象 *target* 自身属性，也可以判断旧值与新值是否相等，只有满足以上两个条件之一时，才有可能执行 *trigger*。



### 8. ***v-model* 双向绑定的原理是什么？**

> 参考答案：
>
> *v-model* 本质就是 *:value + input* 方法的语法糖。可以通过 *model* 属性的 *prop* 和 *event* 属性来进行自定义。原生的 *v-model*，会根据标签的不同生成不同的事件和属性。
>
> 例如：
>
> - *text* 和 *textarea* 元素使用 *value* 属性和 *input* 事件
> - *checkbox* 和 *radio* 使用 *checked* 属性和 *change* 事件
> - *select* 字段将 *value* 作为 *prop* 并将 *change* 作为事件
>
> 以输入框为例，当用户在输入框输入内容时，会触发 *input* 事件，从而更新 *value*。而 *value* 的改变同样会更新视图，这就是 *vue* 中的双向绑定。双向绑定的原理，其实现思路如下：
>
> 首先要对数据进行劫持监听，所以我们需要设置一个监听器 *Observer*，用来监听所有属性。如果属性发上变化了，就需要告诉订阅者 *Watcher* 看是否需要更新。
>
> 因为订阅者是有很多个，所以我们需要有一个消息订阅器 *Dep* 来专门收集这些订阅者，然后在监听器 *Observer* 和订阅者 *Watcher* 之间进行统一管理的。
>
> 接着，我们还需要有一个指令解析器 *Compile*，对每个节点元素进行扫描和解析，将相关指令对应初始化成一个订阅者 *Watcher*，并替换模板数据或者绑定相应的函数，此时当订阅者 *Watcher* 接收到相应属性的变化，就会执行对应的更新函数，从而更新视图。
>
> 因此接下去我们执行以下 *3* 个步骤，实现数据的双向绑定：
>
> 1. 实现一个监听器 *Observer*，用来劫持并监听所有属性，如果有变动的，就通知订阅者。
>
> 2. 实现一个订阅者 *Watcher*，可以收到属性的变化通知并执行相应的函数，从而更新视图。
>
> 3. 实现一个解析器 *Compile*，可以扫描和解析每个节点的相关指令，并根据初始化模板数据以及初始化相应的订阅器。
>
> 流程图如下：
>
> <img src="https://img-blog.csdnimg.cn/img_convert/717034f25ee385b09e9dee53b2988cae.png" alt="img"  />



### 9. ***vue2.x* 和 *vuex3.x* 渲染器的 *diff* 算法分别说一下？**

> 直播讲解

> 参考答案：
>
> 简单来说，*diff* 算法有以下过程
>
> - 同级比较，再比较子节点
> - 先判断一方有子节点一方没有子节点的情况(如果新的 *children* 没有子节点，将旧的子节点移除)
> - 比较都有子节点的情况(核心 *diff*)
> - 递归比较子节点
>
> 正常 *Diff* 两个树的时间复杂度是 *O(n^3)*，但实际情况下我们很少会进行跨层级的移动 *DOM*，所以 *Vue* 将 *Diff* 进行了优化，从*O(n^3) -> O(n)*，只有当新旧 *children* 都为多个子节点时才需要用核心的 *Diff* 算法进行同层级比较。
>
> *Vue2* 的核心 *Diff* 算法采用了双端比较的算法，同时从新旧 *children* 的两端开始进行比较，借助 *key* 值找到可复用的节点，再进行相关操作。相比 *React* 的 *Diff* 算法，同样情况下可以减少移动节点次数，减少不必要的性能损耗，更加的优雅。
>
> *Vue3.x* 借鉴了 *ivi* 算法和 *inferno* 算法
>
> 在创建 *VNode* 时就确定其类型，以及在 *mount/patch* 的过程中采用位运算来判断一个 *VNode* 的类型，在这个基础之上再配合核心的 *Diff* 算法，使得性能上较 *Vue2.x* 有了提升。该算法中还运用了动态规划的思想求解最长递归子序列。

