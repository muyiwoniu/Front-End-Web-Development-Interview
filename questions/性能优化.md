# 大厂前端面试题精选

## 性能优化 部分

### 1. 懒加载的概念
懒加载也叫做延迟加载、按需加载，指的是在长网页中延迟加载图片数据，是一种较好的网页性能优化的方式。在比较长的网页或应用中，如果图片很多，所有的图片都被加载出来，而用户只能看到可视窗口的那一部分图片数据，这样就浪费了性能。
如果使用图片的懒加载就可以解决以上问题。在滚动屏幕之前，可视化区域之外的图片不会进行加载，在滚动屏幕时才加载。这样使得网页的加载速度更快，减少了服务器的负载。懒加载适用于图片较多，页面列表较长（长列表）的场景中。

### 2. 懒加载的特点
减少无用资源的加载：使用懒加载明显减少了服务器的压力和流量，同时也减小了浏览器的负担。
提升用户体验: 如果同时加载较多图片，可能需要等待的时间较长，这样影响了用户体验，而使用懒加载就能大大的提高用户体验。
防止加载过多图片而影响其他资源文件的加载 ：会影响网站应用的正常使用。

### 3. 懒加载的实现原理
图片的加载是由 src 引起的，当对 src 赋值时，浏览器就会请求图片
资源。根据这个原理，我们使用 HTML5 的 data-xxx 属性来储存图片
的路径，在需要加载图片的时候，将 data-xxx 中图片的路径赋值给
src，这样就实现了图片的按需加载，即懒加载。
注意：data-xxx 中的 xxx 可以自定义，这里我们使用 data-src 来定
义。
懒加载的实现重点在于确定用户需要加载哪张图片，在浏览器中，可
视区域内的资源就是用户需要的资源。所以当图片出现在可视区域时，
获取图片的真实地址并赋值给图片即可。
使用原生 JavaScript 实现懒加载：
知识点：
window.innerHeight 是浏览器可视区的高度
document.body.scrollTop
document.documentElement.scrollTop 是浏览器滚动的过的距离
imgs.offsetTop 是元素顶部距离文档顶部的高度（包括滚动条的距
离）
图 片 加 载 条 件 ： img.offsetTop < window.innerHeight +
document.body.scrollTop;
图示：
![图片懒加载](../assets/images/%E5%9B%BE%E7%89%87%E6%87%92%E5%8A%A0%E8%BD%BD.jpg)

代码实现：
```
<div class="container">
    <img src="loading.gif" data-src="pic.png">
    <img src="loading.gif" data-src="pic.png">
    <img src="loading.gif" data-src="pic.png">
    <img src="loading.gif" data-src="pic.png">
    <img src="loading.gif" data-src="pic.png">
    <img src="loading.gif" data-src="pic.png">
</div>
<script>
    var imgs = document.querySelectorAll('img');

    function lazyLoad() {
        var scrollTop = document.body.scrollTop || document.documentdocumentElement.scrollTop;
        var winHeight = window.innerHeight;
        for (var i = 0; i < imgs.length; i++) {
            if (imgs[i].offsetTop < scrollTop + winHeight) {
                imgs[i].src = imgs[i].getAttribute('data-src');
            }
        }
    }
window.onscroll = lazyLoad();
</script>
```

### 4. 回流与重绘的概念及触发条件
1. 回流
当渲染树中部分或者全部元素的尺寸、结构或者属性发生变化时，浏览器会重新渲染部分或者全部文档的过程就称为回流。
下面这些操作会导致回流：
页面的首次渲染
浏览器的窗口大小发生变化
元素的内容发生变化
元素的尺寸或者位置发生变化
元素的字体大小发生变化
激活 CSS 伪类
查询某些属性或者调用某些方法
添加或者删除可见的 DOM 元素
在触发回流（重排）的时候，由于浏览器渲染页面是基于流式布局的，所以当触发回流时，会导致周围的 DOM 元素重新排列，它的影响范围有两种：
全局范围：从根节点开始，对整个渲染树进行重新布局
局部范围：对渲染树的某部分或者一个渲染对象进行重新布局
2. 重绘
当页面中某些元素的样式发生变化，但是不会影响其在文档流中的位置时，浏览器就会对元素进行重新绘制，这个过程就是重绘。
下面这些操作会导致重绘：
color、background 相关属性：background-color、background-image 等
outline 相关属性 ： outline-color、outline-width、text-decoration
border-radius、visibility、box-shadow
注意： 当触发回流时，一定会触发重绘，但是重绘不一定会引发回流。

### 5. 如何避免回流与重绘？
减少回流与重绘的措施：
操作 DOM 时，尽量在低层级的 DOM 节点进行操作。
不要使用 table 布局， 一个小的改动可能会使整个 table 进行重新布局。
使用 CSS 的表达式。
不要频繁操作元素的样式，对于静态页面，可以修改类名，而不是样式。
使用 absolute 或者 fixed，使元素脱离文档流，这样他们发生变化就不会影响其他元素。
避免频繁操作 DOM，可以创建一个文档片段 documentFragment，在它上面应用所有 DOM 操作，最后再把它添加到文档中。
将元素先设置 display: none，操作结束后再把它显示出来。因为在 display 属性为 none 的元素上进行的 DOM 操作不会引发回流和重绘。
将 DOM 的多个读操作（或者写操作）放在一起，而不是读写操作穿插着写。这得益于浏览器的渲染队列机制。
浏览器针对页面的回流与重绘，进行了自身的优化——渲染队列：
浏览器会将所有的回流、重绘的操作放在一个队列中，当队列中的操作到了一定的数量或者到了一定的时间间隔，浏览器就会对队列进行批处理。这样就会让多次的回流、重绘变成一次回流重绘。
上面，将多个读操作（或者写操作）放在一起，就会等所有的读操作进入队列之后执行，这样，原本应该是触发多次回流，变成了只触发一次回流。

### 6. 如何优化动画？
对于如何优化动画，我们知道，一般情况下，动画需要频繁的操作 DOM，就就会导致页面的性能问题，我们可以将动画的 position 属性设置为 absolute 或者 fixed，将动画脱离文档流，这样它的回流就不会影响到页面了。
